/*
modes
 0 obstacle
 1 stains target_in_cam
 2 stains target_move_fwd_clean
 3 stains 360 
 4 seat 360
 5 seat move
 6 seat cetralise
 7 seat clean_rot
 8 seat clean_scrub
 9 bowl
 
*/

#include <avr/io.h>
#include <avr/wdt.h>
#define F_CPU 16000000UL
#include <util/delay.h>
#include <avr/interrupt.h>
#include "Stepper.h"
#include "PinChangeInterrupt.h"

/////////sonar///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define PI_APP 3.14159265359

#define TICKS_PER_MS 15984               // instructions per millisecond (depends on MCU clock, 12MHz current)
#define MAX_RESP_TIME_MS 40      // timeout - max time to wait for low voltage drop (higher value increases measuring distance at the price of slower sampling)
#define DELAY_BETWEEN_TESTS_US 200 // echo cancelling time between sampling

#define THRESHOLD 20
#define DIST_LIMIT 500

#define ECHO1 51
#define TRIG1 46
#define ECHO2 52
#define TRIG2 47
#define ECHO3 53
#define TRIG3 45

#define NUM_OF_READINGS 5


#define pinBlink1 51
#define pinBlink2 52
#define pinBlink3 2



volatile long result1 = 0;
volatile unsigned char up1 = 0;
volatile unsigned char running1 = 0;
volatile uint32_t timerCounter1 = 0;

volatile long result2 = 0;
volatile unsigned char up2 = 0;
volatile unsigned char running2 = 0;
volatile uint32_t timerCounter2 = 0;

volatile long result3 = 0;
volatile unsigned char up3 = 0;
volatile unsigned char running3 = 0;
volatile uint32_t timerCounter3 = 0;

volatile uint16_t dummy[3] = {0,0,0};

volatile  uint32_t max_ticks = (uint32_t)MAX_RESP_TIME_MS*TICKS_PER_MS; 
//  = 480000 this could be replaced with a value instead of multiplying

volatile int distCnt[3] = {0};
volatile int distData1[NUM_OF_READINGS] = {0}; 
volatile int distData2[NUM_OF_READINGS] = {0};
volatile int distData3[NUM_OF_READINGS] = {0};
volatile int distSum1 = 0, distSum2 = 0, distSum3 = 0;

volatile int dist[3] ={1000, 1000, 1000};

volatile int time = 0, prev_time = 0, exec_time = 0;

volatile int dataCnt = 0;

volatile char inputstring[100];

////////////////////sonar////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////encoder/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define encoder2PinA 18
//#define encoder2PinB 19
#define encoder1PinA 20
//#define encoder1PinB 3

volatile double tick1;
volatile double tick2;

//volatile int in;
////////////////////encoder/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////digital_pwm_pins/////////////////////////////////////////////////////////////////////////////////////////////////////
# define seat_solenoid 21
# define floor_solenoid 22
# define seat_scrubber 23
# define floor_scrubber 24

#define MotorDir1 11
#define MotorBrk1 9
#define MotorPwm1 12
#define MotorDir2 5
#define MotorBrk2 7
#define MotorPwm2 13///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////digital_pwm_pins/////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////r_theta_update_parameter/////////////////////////////////////////////////////////////////////////////////////////////////////
#define angle_dist 0.082
//#define angle_angle 19
#define wheel_gap 56
#define filter_cam 0.5
#define filter_enc 0.5
#define filter_sonar 0
/////////////////////r_theta_update_para/////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////mode_para/////////////////////////////////////////////////////////////////////////////////////////////////////
#define cleaning_dist -30
#define moving_dist 110
#define obtacle_dist 0.5
#define centralise_dist 0.5
#define centralise_theta_margin 5
#define centralise_dist_margin 0.5

# define angle_error 5

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////mode_para/////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////PID_VAR/////////////////////////////////////////////////////////////////////////////////////////////////////
float theta_error =0 , theta_le = 0;
float theta_integral=0;
float theta_diff=0;
float theta_pid =0;

float r_error =0 , r_le = 0;
float r_integral=0;
float r_diff=0;
float r_pid =0;

volatile double t =0 , lt = 0 ,dt =0 ;
volatile int pwm;
volatile int pwm1;
volatile int pwm2;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////PID_VAR/////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////R_THETA/////////////////////////////////////////////////////////////////////////////////////////////////////

int dir1;
int dir2;


double r,theta;
double r_in,theta_in;
double serial_seat_r,serial_seat_theta;
int serial_stain_r,serial_stain_theta;
int stain_vis,seat_vis,seat_stain_vis;
int serial_seat_alpha;

double wheel_1_rot = 0,wheel_2_rot = 0;


int turning_90 =0;
int turning_360 = 0;
int no_of_rot =0;

int mode;
int cur_mode;
double ANGLE;
int stepsPerRevolution = 360;

//////////////////////////////////////////////////////////////stepper//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Stepper Stepper1(stepsPerRevolution, 47, 49, 51, 53);//change pins
# define stepperSpeed 21
int seat_cleaner_pos;
int alpha;
//////////////////////////////////////////////////////////////stepper//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////min_count//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int time_min=0;
long m_time=0.0;
long m_prev_time = 0 ;
//////////////////////////////////////////////////////////////min_count//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void pin_setup ()
 {
   pinMode(seat_solenoid,OUTPUT);
   pinMode(floor_solenoid,OUTPUT);
   pinMode(floor_scrubber,OUTPUT);
   pinMode(seat_scrubber,OUTPUT);
  // pinMode(seat_solenod,OUTPUT); 
 }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*
void runStepper(int alpha)
{  
  Stepper1.step(alpha);
}
*/
void stepper_init()
{
  Stepper1.setSpeed(stepperSpeed);   
}

void seat_clean ()
 {
   digitalWrite ( seat_solenoid, HIGH);
   digitalWrite ( seat_scrubber, HIGH);
   delay(5000);
   digitalWrite ( seat_solenoid, LOW);
   delay(2000);
   digitalWrite ( seat_scrubber, LOW);
 } 
 
 void floor_clean ()
 {
   digitalWrite ( floor_solenoid, HIGH);
   digitalWrite ( floor_scrubber, HIGH);
   delay(5000);
   digitalWrite ( floor_solenoid, LOW);
   delay(2000);
   digitalWrite ( floor_scrubber, LOW);
 } 
   
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void position_cleaner (int alpha)
 {
   int steps;
   steps = alpha / 360 *stepsPerRevolution;
   Stepper1.step(steps);
   seat_cleaner_pos  = (seat_cleaner_pos+alpha)%360;
 }

void seat_cleaner_home ()
 {
   int STEPS;
   STEPS = -1 * seat_cleaner_pos / 360 * stepsPerRevolution;
   Stepper1.step(STEPS);
   seat_cleaner_pos = 0 ;
 }

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
void min_counter ()
 {
   m_time = millis();
   if (time - m_prev_time >= 60000)
    {
      m_prev_time = m_time;
      time_min  = time_min+ 1;
    }  
 }
   
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void move_straight(int dist)
{
  pwm2 = pwm;
  if (pwm != 0)
   {
     pwm1 = pwm + 5;
   }
  else
  {
     pwm1 = 0;
  } 
  if(dist>0)
  {
  digitalWrite(MotorDir1,LOW);
  digitalWrite(MotorDir2,LOW);
  digitalWrite(MotorBrk1,LOW);
  digitalWrite(MotorBrk2,LOW);
  dir1 = 1;
  dir2= 1;
  }

  if(dist<0)
 {
  digitalWrite(MotorDir1,HIGH);
  digitalWrite(MotorDir1,HIGH);
  digitalWrite(MotorBrk1,LOW);
  digitalWrite(MotorBrk2,LOW);
  dir1 = -1;
  dir2 = -1;
 }
   
 analogWrite(MotorPwm1,abs(pwm1));
 analogWrite(MotorPwm2,abs(pwm2));
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void turn(int angle)
{
  pwm2 = pwm;
  if (pwm != 0)
   {
    pwm1 = pwm + 5;
   }
  else
  {
   pwm1 = 0;
  }
  if(angle>0)
  {
  digitalWrite(MotorDir1,LOW);
  digitalWrite(MotorDir2,HIGH);
  digitalWrite(MotorBrk1,LOW);
  digitalWrite(MotorBrk2,LOW);
  dir1 = 1;
  dir2 = -1;
  }

  if(angle<0)
 {
  digitalWrite(MotorDir1,HIGH);
  digitalWrite(MotorDir1,LOW);
  digitalWrite(MotorBrk1,LOW);
  digitalWrite(MotorBrk2,LOW);
  dir1 = -1;
  dir2 = 1;
 }
   
 analogWrite(MotorPwm1,abs(pwm1));
 analogWrite(MotorPwm2,abs(pwm2));
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Brake()
{
    digitalWrite(MotorBrk1,HIGH);
    digitalWrite(MotorBrk2,HIGH);
    analogWrite(MotorPwm1,0);
    analogWrite(MotorPwm2,0);
    dir1 = 0;
    dir2 = 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

char c;
int flag = 0;
int num = 0;
int n = 0;
int i = 0;
int len = 0;

//int stain_vis,serial_stain_theta,serial_stain_r;

int index1 = 0;
int index2 = 0;
int index3 = 0;
int index4 = 0;

String s = "";
String inputString = "";         // a string to hold incoming data
String ss1 = ""; 
String ss2 = "";
String ss3 = ""; 
boolean stringComplete = false;
String send_data = "";


void comm_init() 
{
  Serial.begin(115200);
  inputString.reserve(200);
  send_data.reserve(200);
}


void serialEvent()
{
  cli();
  //Brake();
 // k = 0;
 //Serial.println(" dddd");
  while (Serial.available() )
  {
    //inputString = "";
    // get the new byte:
    char inChar = (char)Serial.read();
    // add it to the inputString:
    inputString += inChar;
    // if the incoming character is a newline, set a flag
    // so the main loop can do something about it:

    if (inChar == '\n')
    {
      stringComplete = true;
    }
  }
  sei ();
  comm_data();	
}




void comm_data() {
  if (stringComplete) {
    Serial.println(inputString);
    // clear the string:
    s = inputString;
    len = s.length();
    for (i = 0; i < len; i++)
    {
      c = s[i];
     /* if ((c == ' ') && (flag == 0))
      {
        num = (s.substring(0, i)).toInt();
        flag = 1;
        i--;
        c = s[i];
      }*/

      if (c == ';')
      {
        index1 = i + 1;
        while (s[i] != ',')
        {
          i++;
        }
        index2 = i;
        while (s[i] != '-')
        {
          i++;
        }
        index3 = i ;
        while (s[i] != ';')
        {
          i++;
        }
        index4 = i ;
        ss1 = s.substring(index1, index2);
        //Serial.print(k);Serial.print("\t");Serial.print(dat[k].x);Serial.print(",");
        ss2 = s.substring((index2 +1 ), (index3));
        //Serial.println(dat[k].y);
        ss3 = s.substring((index3 + 1), index4);

        c = s[i];
      }

    }
    //send_data = "";
    
      stain_vis = (ss1).toInt();
      serial_stain_r = (ss2).toInt();
      serial_stain_theta = (ss3).toInt();
      //send_data += dat[i].x + "_" + dat[i].y;
   
    //send_data[i] = '\0';

    inputString = "";
    stringComplete = false;
  }
}







/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



void update_r_theta ()
{
  double d1,d2;
  d1 = angle_dist*wheel_1_rot;
  d2 = angle_dist*wheel_2_rot;
  if (mode == 1 || mode == 5)
   {
     if ( abs(abs(d2)-abs(d1))>=0.05 )
       {
         r = filter_cam*r_in + filter_enc*(r - (d2+d1)*wheel_gap/(2*(d2-d1))*sin((d2-d1)/wheel_gap));
         theta = filter_cam*theta_in + filter_enc*(theta + (d2-d1)/wheel_gap);
       }
     else
       {
         r = filter_cam*r_in + filter_enc*(r - (d2+d1)/(2));
         theta = filter_cam*theta_in + filter_enc*(theta + (d2-d1)/wheel_gap);
       }
        
   }
   else if (mode ==0 || mode == 2 || mode == 3 || mode == 4 )
   {
      if ( abs(abs(d2)-abs(d1))>=0.05 )
       {
         r =  (r - (d2+d1)*wheel_gap/(2*(d2-d1))*sin((d2-d1)/wheel_gap));
         theta = (theta + (d2-d1)/wheel_gap);
       }
     else
       {
         r = (r - (d2+d1)/(2));
         theta = (theta + (d2-d1)/wheel_gap);
       }
   }
  else if (mode == 6)
   {
     if ( abs(abs(d2)-abs(d1))>=0.05 )
       {
         r = filter_cam*r_in + filter_enc*(r - (d2+d1)*wheel_gap/(2*(d2-d1))*sin((d2-d1)/wheel_gap)) + filter_sonar*dist[1];
         theta = filter_cam*theta_in + filter_enc*(theta + (d2-d1)/wheel_gap);
       }
     else
       {
         r = filter_cam*r_in + filter_enc*(r - (d2+d1)/(2)) + filter_sonar*dist[1];
         theta = filter_cam*theta_in + filter_enc*(theta + (d2-d1)/wheel_gap);
       }
        
   }
   
 }



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
///////////////////////////////  


void diff_motion (int mode , int r , int theta)
  {
    int dir_360 = 1;
    update_r_theta ();
    PID();
    
    if (mode ==0)
     {
      /* 
       if (turning_90 == 0)
        {
          theta = (dist[0] == dist[2]) ?  90 : (dist[0] - dist[2])*90/(abs(dist[0] - dist[2]));
          turning_90 = 1;
        }
       
       if (abs (theta) < angle_error )
        {
          turning_90 = 0;
          set_mode();
        }
        turn (theta);*/
     }  
     
    if (mode == 1 || mode == 5 || mode == 6)
     { 
       if (abs (theta) < angle_error )
         {
           move_straight (r);
         }
       else
         {
           turn  (theta);
         }
     }
     
   if (mode == 2 )
     { 
       if (abs (theta) >= angle_error )
         {
           turn (theta);
         }
       else if (r >= cleaning_dist)
         {
           move_straight (r);
         }
       else
         {
           Brake();
           floor_clean();
         }
     } 
     
   if (mode == 3 )
     { /*
       if (turning_360 == 0)
        {
          theta = 10;
          dir_360 = (dist[0] == dist[2]) ?  1 : (dist[0] - dist[2])*1/(abs(dist[0] - dist[2]));
          theta = theta * dir_360;
          ANGLE = 0;
          no_of_rot = 0;
          turning_360 = 1;
        }
         
        turn (theta);
     
       if (abs (theta) < angle_error && turning_360 == 1 )
        {
          ANGLE= ANGLE +10;
          theta = 10;
          theta = theta * dir_360;
          if ( ANGLE >= 360 && ANGLE < 720 )
           {
             no_of_rot = no_of_rot +1;
             turning_360 = 0;
           }
          else if ( ANGLE >= 720)
           {
             turning_360 = 0;
           }
          set_mode();
        }*/
        Brake();

     } 
     
     
if (mode == 4 )
     { /*
       if (turning_360 == 0)
        {
          dir_360 = (dist[0] == dist[2]) ?  90 : (dist[0] - dist[2])*1/(abs(dist[0] - dist[2]));
          theta = 10;
          theta = theta * dir_360;
          ANGLE = 0;
          turning_360 = 1;
        }         
        turn (theta);       
       if (abs (theta) < angle_error && turning_360 == 1 )
        {
          ANGLE= ANGLE +10;
          theta = 10;
          theta = theta * dir_360;
          set_mode();
        }
       */
     } 
/*     
if ( mode == 6)
     { 
       if (abs (theta) < angle_error)
         {
           forward (r);
         }
       else if (abs (theta) > 70)
         {
           r = -5;
           forward(r);
         }  
       else
         {
           turn  (theta);
         }
     }*/
if ( mode == 9)
     { 
       Brake();
     }     
     
         
 }  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




void PID()
{
  if (theta >= angle_error)
   {
      theta_le = theta_error;
      theta_error = 0 - theta;
      theta_integral = theta_integral + theta_error * dt;
      theta_diff = (theta_error - theta_le)/dt;
      theta_pid = 5.5*theta_error +0.0*theta_integral + 0.0*theta_diff;
      
      
      pwm = (int)(constrain(theta_pid,-220,220));
      pwm = map(pwm,-255,255,-110,110);
      pwm = pwm * (-1);
      if (abs(pwm)<15)
         {
           pwm = 0;
         }
   }
 else
   {
      r_le = r_error;
      r_error = 0 - r;
      r_integral = r_integral + r_error * dt;
      r_diff = (r_error - r_le)/dt;
      r_pid = 5.5*r_error +0.0*r_integral + 0.0*r_diff;
      
      
      pwm = (int)(constrain(r_pid,-220,220));
      pwm = map(pwm,-255,255,-110,110);
      pwm = pwm * (-1);
      if (abs(pwm)<15)
         {
           pwm = 0;
         }
   }   
  
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void serial_print()
 {
   Serial.print(r);
   Serial.print("      ");
   Serial.print(theta);
   Serial.print("      ");
   Serial.print(mode);
   Serial.print("      ");
   Serial.print(pwm1);
   Serial.print("      ");
   Serial.print(pwm2);
    Serial.print("                                  ");
   Serial.print(stain_vis);
    Serial.print("      ");
   Serial.print(serial_stain_r);
    Serial.print("      ");
   Serial.print(serial_stain_theta);
   Serial.print("                               ");
   Serial.print(r_in);
   Serial.print("      ");
   Serial.print(theta_in);
   Serial.println("      ");   
 }  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


void set_mode ()
 {
                                                                                   r_in = serial_stain_r;
                                                                                   theta_in = serial_stain_theta;
   int centralised;
   /*if ((( dist[1] <= obtacle_dist) || (turning_90 ==1)) && (mode != 6))
     {
       mode = 0;
     }*/
   if (stain_vis == 1 && r_in >= moving_dist && time_min <= 7 &&  no_of_rot <= 0 )
     {
       mode = 1;
       turning_360 = 0;
       //r_in = serial_stain_r;
       //theta_in = serial_stain_theta;
     }
   else if (stain_vis == 1 && serial_stain_r <= moving_dist && time_min <= 7 )
     {
       mode = 2;
       turning_360 = 0;
     } 
    else if (stain_vis == 0 && time_min <= 7 && no_of_rot <= 0 )
     {
       mode = 3;
     }
     /*
    else if ((seat_vis == 1) && ((time_min >= 7) || ( (stain_vis = 0) && (no_of_rot >= 1) ) ))
     {
       mode = 5;
       turning_360 = 0;
       r_in = serial_seat_r;
       theta_in = serial_seat_theta;
     }
     else if ((seat_vis == 0) && ((time_min >= 7) || ( (stain_vis = 0) && (no_of_rot >= 1) ) ))
     {
       mode = 4;
     }
   else if (((seat_vis == 1) && ((time_min >= 7) || ( (stain_vis = 0) && (no_of_rot >= 1) ) )) && (serial_seat_r <= centralise_dist ))
     {
       mode = 6;
       if (r <=centralise_dist_margin) 
        {
          centralised = 1;
          Brake();
        }
     } 
    else if (centralised == 1 && seat_stain_vis == 1)
     {
       mode = 7;  
       alpha = serial_seat_alpha;
       position_cleaner(alpha);
       seat_clean();
       seat_cleaner_home();    
            
     }
   
   
   //mode = 2;*/
 }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void diff_motor_setup ()
 {    
     EIMSK = 0;
    
    //EIMSK |= (1 << INT2);
    EIMSK |= (1 << INT3);
    //EIMSK |= (1 << INT0);
    EIMSK |= (1 << INT1);
   // EIMSK |= (1 << INT5);
    
    
    EICRA = 0;
 
    EICRB = 0;
    //EICRA |= (1 << ISC20);
    EICRA |= (1 << ISC30);
   // EICRA |= (1 << ISC00);
    EICRA |= (1 << ISC10);
    //EICRB |= (1 << ISC50);
   
   /* 
    attachInterrupt(digitalPinToInterrupt(encoder1PinA), int3, CHANGE);
    attachInterrupt(digitalPinToInterrupt(encoder1PinB), int2, CHANGE);
    attachInterrupt(digitalPinToInterrupt(encoder2PinA), int5, CHANGE);
    attachInterrupt(digitalPinToInterrupt(encoder2PinB), int4, CHANGE);
    */
    pinMode(MotorDir1,OUTPUT);
    pinMode(MotorBrk1,OUTPUT);
    pinMode(MotorPwm1,OUTPUT);
    pinMode(MotorDir2,OUTPUT);
    pinMode(MotorBrk2,OUTPUT);
    pinMode(MotorPwm2,OUTPUT);
  
    pinMode(encoder1PinA, INPUT); 
    //pinMode(encoder1PinB, INPUT);
    pinMode(encoder2PinA, INPUT); 
    //pinMode(encoder2PinB, INPUT); 
 }

void setup() 
{
  pin_setup();
  sei();
  diff_motor_setup();
  stepper_init();
 // sonar_Init();
  comm_init();
  mode =9;
  delay(3000);
  r =90;
  mode =9;
  
}

void loop() 
{
    double pos1,pos2;
    pos1 = tick1;
    pos2 = tick2;
    
    t = millis()/1000.0;
    
    //handleObstacle(5);
    set_mode();
    update_r_theta();
    diff_motion(mode,r,theta);
    min_counter ();
    serial_print(); 
    //Serial.println("Before Event");
   // serial_Event();
   // Serial.println("After Event");
   //pwm = 25;
    //move_straight(10);
   /* 
    
    if ((tick2 <= 180))
      {
        move_straight(10);
      }
    else  
      {
        Brake();
        delay (7000);
        tick1 = 0;
        tick2 = 0;
       
      }
    */
      
      
    lt = t;
    t = millis()/1000.0;
    dt = t -lt;
    wheel_1_rot = ( tick1 - pos1)*dir1;
    wheel_2_rot = (tick2 - pos2)*dir2;
    
   
  // put your main code here, to run repeatedly:
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*ISR (INT2_vect)
{
  //inq++;
  tick2 = tick2 + 0.0079;
 
}*/

ISR (INT3_vect)
{
  //inq++;
  tick2 = tick2 + 0.0079;
    
} 

/*ISR (INT0_vect)
{
  //inq++;
  tick1 = tick1 + 0.0075;	
}*/

ISR (INT1_vect)
{
  //inq++;
  tick1 = tick1 + 0.0075; 
  
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* BASIC FUNCTIONS */
/*
void setPin(int pin)
{
  digitalWrite(pin, HIGH); 
}

void resetPin(int pin)
{
  digitalWrite(pin, LOW); 
}

/***********************************************************************************/
/* INTERRUPT HANDLERS */

// Timer overflow interrupt for Left Sonar/*
/*
ISR(TIMER3_OVF_vect)
{      
    if (up1) 
    {       // voltage rise was detected previously
    timerCounter1++; // count the number of overflows
    // dont wait too long for the sonar end response, stop if time for measuring the distance exceeded limits
    uint32_t ticks1 = timerCounter1 * 65535 + TCNT3;
        if (ticks1 > max_ticks) 
      {
          // timeout
          up1 = 0;          // stop counting timer values
          running1 = 0; // ultrasound scan done
          result1 = 1000; // show that measurement failed with a timeout (could return max distance here if needed)
      }
    }    
}

// Timer overflow interrupt for Center Sonar
ISR(TIMER4_OVF_vect)
{      
    if (up2) 
    {       // voltage rise was detected previously
    timerCounter2++; // count the number of overflows
    // dont wait too long for the sonar end response, stop if time for measuring the distance exceeded limits
    uint32_t ticks2 = timerCounter2 * 65535 + TCNT4;
        if (ticks2 > max_ticks) 
      {
          // timeout
          up2 = 0;          // stop counting timer values
          running2 = 0; // ultrasound scan done
          result2 = 1000; // show that measurement failed with a timeout (could return max distance here if needed)
      }
    }    
}

// Timer overflow interrupt for Right Sonar
ISR(TIMER5_OVF_vect)
{      
    if (up3) 
    {       // voltage rise was detected previously
    timerCounter3++; // count the number of overflows
    // dont wait too long for the sonar end response, stop if time for measuring the distance exceeded limits
    uint32_t ticks3 = timerCounter2 * 65535 + TCNT5;
        if (ticks3 > max_ticks) 
      {
          // timeout
          up3 = 0;          // stop counting timer values
          running3 = 0; // ultrasound scan done
          result3 = 1000; // show that measurement failed with a timeout (could return max distance here if needed)
      }
    }    
}*/

/*
// Echo Interrupt Handler for Right Sonar
void blinkLed1()
{
  if (running1) 
  { //accept interrupts only when sonar was started
    if (up1 == 0) 
    { // voltage rise, start time measurement
        up1 = 1;
        timerCounter1 = 0;
        TCNT3 = 0; // reset timer counter
    }
    else 
    {        // voltage drop, stop time measurement
        up1 = 0;
        // convert from time to distance(millimeters): d = [ time_s * 340m/s ] / 2 = time_us/58
        result1 = (timerCounter1 * 65535 + TCNT3)/940;
        dummy[0] = TCNT3;
        running1 = 0;
     }
  }
} */
/*
// Echo Interrupt Handler for Left Sonar
void blinkLed2()
{ 
  if (running2) 
  { //accept interrupts only when sonar was started
    if (up2 == 0) 
    { // voltage rise, start time measurement
        up2 = 1;
        timerCounter2 = 0;
        TCNT4 = 0; // reset timer counter
    }
    else 
    {        // voltage drop, stop time measurement
        up2 = 0;
        // convert from time to distance(millimeters): d = [ time_s * 340m/s ] / 2 = time_us/58
        result2 = (timerCounter2 * 65535 + TCNT4)/940;
        dummy[1] = TCNT4;
        running2 = 0;
     }
  }
}

// Echo Interrupt Handler for Right Sonar
void blinkLed3()
{
  if (running3) 
  { //accept interrupts only when sonar was started
    if (up3 == 0) 
    { // voltage rise, start time measurement
        up3 = 1;
        timerCounter3 = 0;
        TCNT5 = 0; // reset timer counter
    }
    else 
    {        // voltage drop, stop time measurement
        up3 = 0;
        // convert from time to distance(millimeters): d = [ time_s * 340m/s ] / 2 = time_us/58
        result3 = (timerCounter3 * 65535 + TCNT5)/940;
        dummy[2] = TCNT5;
        running3 = 0;
     }
  }
}
*/
/*************************************************************************************/
/* SONAR FUNCTIONS */

/*

void sonar(int num) 
{
  if(num == 1)
  {
  resetPin(TRIG1);
  delayMicroseconds(1);
  setPin(TRIG1);
  delayMicroseconds(10);
  resetPin(TRIG1);
  delayMicroseconds(1);
  running1 = 1;  
  }
  else if(num == 2)
  {
  resetPin(TRIG2);
  delayMicroseconds(1);
  setPin(TRIG2);
  delayMicroseconds(10);
  resetPin(TRIG2);
  delayMicroseconds(1);
  running2 = 1; 
  }    
  else if(num == 3)
  {
  resetPin(TRIG3);
  delayMicroseconds(1);
  setPin(TRIG3);
  delayMicroseconds(10);
  resetPin(TRIG3);
  delayMicroseconds(1);
  running3 = 1; 
  }      
}

void handleObstacle(int cnt)
{  
    while(cnt--)
    {
      // Sonar-1
      if(running1 == 0)
      {
        distData1[distCnt[0]] = result1;
        distCnt[0]++;
        
        if(distCnt[0] == NUM_OF_READINGS)
          distCnt[0] = 0;
        int n;  
        distSum1 = 0;
        for(n=0; n<NUM_OF_READINGS; n++)
        {
          distSum1 += distData1[n]; 
        }  
                
        dist[0] = distSum1/NUM_OF_READINGS;
        
        if(dist[0] > DIST_LIMIT && dist[0] != 1000)
          dist[0] = DIST_LIMIT;
        
        sonar(1); // launch measurement 
      }
      // Sonar-2
      if(running2 == 0)
      {
        distData2[distCnt[1]] = result2;
        distCnt[1]++;
        
        if(distCnt[1] == NUM_OF_READINGS)
          distCnt[1] = 0;
        int n;  
        distSum2 = 0;
        for(n=0; n<NUM_OF_READINGS; n++)
        {
          distSum2 += distData2[n]; 
        }  
                
        dist[1] = distSum2/NUM_OF_READINGS;
        
        if(dist[1] > DIST_LIMIT  && dist[1] != 1000)
          dist[1] = DIST_LIMIT;
        
         sonar(2); 
      }
      
      // Sonar-3
      if(running3 == 0)
      {
        distData3[distCnt[2]] = result3;
        distCnt[2]++;
        
        if(distCnt[2] == NUM_OF_READINGS)
          distCnt[2] = 0;
        int n;  
        distSum3 = 0;
        for(n=0; n<NUM_OF_READINGS; n++)
        {
          distSum3 += distData3[n]; 
        }  
                
        dist[2] = distSum3/NUM_OF_READINGS;
        
        if(dist[2] > DIST_LIMIT  && dist[2] != 1000)
          dist[2] = DIST_LIMIT;
        
         sonar(3); 
      }
    }
}
*/
/*************************************************************************************/
/* INITIALIZATION FUNCTIONS */
/*
void tim3_Init()
{
  TCCR3A = 0;
  TCCR3B = 0;
  
  TCCR3B |= (1<<CS30); // select internal clock with no prescaling
  TCNT3 = 0; // reset counter to zero
  TIMSK3 = 1<<TOIE3; // enable timer interrupt 
}

void tim4_Init()
{
  TCCR4A = 0;
  TCCR4B = 0;
  
  TCCR4B |= (1<<CS40); // select internal clock with no prescaling
  TCNT4 = 0; // reset counter to zero
  TIMSK4 = 1<<TOIE4; // enable timer interrupt 
}

void tim5_Init()
{
  TCCR5A = 0;
  TCCR5B = 0;
  
  TCCR5B |= (1<<CS50); // select internal clock with no prescaling
  TCNT5 = 0; // reset counter to zero
  TIMSK5 = 1<<TOIE5; // enable timer interrupt 
}

void initializeSonar()
{
  int m;
  
  for(m=0; m<NUM_OF_READINGS; m++)
  {
     distData1[m] = 1000;
     distData2[m] = 1000;
     distData3[m] = 1000;
  } 
}

void pinInit()
{
  pinMode(ECHO1, INPUT);
  pinMode(TRIG1, OUTPUT); 
  pinMode(ECHO2, INPUT);
  pinMode(TRIG2, OUTPUT);
  pinMode(ECHO3, INPUT);
  pinMode(TRIG3, OUTPUT);
}


void sonar_Init()
{
  pinInit();
  
  noInterrupts();
  tim3_Init();
  tim4_Init();
  tim5_Init();
  interrupts(); // enable all(global) interrupts  
  Serial.begin(115200);
  attachPCINT(digitalPinToPCINT(pinBlink1), blinkLed1, CHANGE);
  attachPCINT(digitalPinToPCINT(pinBlink2), blinkLed2, CHANGE);
  attachPCINT(digitalPinToPCINT(pinBlink3), blinkLed3, CHANGE);
   
  initializeSonar(); 
}
*/
